/* TCP网络编程最本质：处理三个半事件
- 连接建立：服务器accept、客户端conne
- 连接断开：主动断开（close, shutdown）、被动断开(read返回0)
- 消息到达：文件描述符可读
- 消息发送完毕：“发送完毕”是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传，不代表对方已经接收到数据。
********************************************************************************************************** */

/*
网络库事件循环中的可读事件触发->将数据从内核缓冲区移动到应用缓冲区
回调函数OnMessage
根据协议判断数据包是不是一个完整的数据包：
1. 不完整则即刻返回OnMessage
2. 是完整的数据包，则从应用的缓冲区中取出read->decode->compute->encode->write
********************************************************************************************************** */

/*
如果数据全部填到了内核缓冲区，网络库回调用OnWriteComplete，
如果内核缓冲区不足以容纳数据，要把数据追加到应用层的发送缓冲区中，
如果应用层的发送缓冲区也发完了则会回调OnWriteComplete
********************************************************************************************************** */

// EchoServer类是基于对象的编程思想


/* 常见并发服务器方案

1. 循环式/迭代式（iterative）服务器
- 无法充分利用多核CPU，不适合执行时间较长的服务

2. 并发式（concurrent）服务器
- one connection per process/thread
- 适合执行时间较长的服务

3. prefork or pre thread
- 预先创建了若干个子进程，减少了创建时的开销，提高了响应速度
- 可能出现“惊群”，多个进程都返回了，只有一个进程返回是正确的（其余是错误的）。

4. 反应式(reactive)服务器（reactor模式）
- 单线程轮询多个客户端：并发处理多个请求，实际上是一个线程中完成。无法充分利用多核CPU
- 不适合执行时间较长的服务，所以为了让客户感觉实在“并发”处理而不是“循环”处理，每个请求必须在相对较短时间内执行。

Linux最理想的模式是：multiple reactors + threadpool （适应突发的I/O请求 + 密集计算）
********************************************************************************************************** */
